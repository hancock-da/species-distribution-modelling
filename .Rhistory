library(tidyverse)
library(ggplot2)
mite <- as_tibble(read.csv("Project/cannibal_data.csv"))
dim(mite)
summary(mite)
head(mite)
# check for NAs. Result is 0 indicating zero missing values
which(is.na(mite))
# Rename column headers for easier reading
mite <- mite %>%
rename(
Time = Time..h.,
Dispersal = Dispersal..0.no..1.yes.,
Lalive = LarvaeAlive....,
Leaten = LarvaeEaten....,
Lmissing = LarvaeMissing....,
Cannibalism = Cannibalism..0.no..1.yes.,
Rate = Rate....h.
)
view(mite)
# Check total number of larvae was same for each observation at start of experiment
tot_larv <- (mite$Lalive + mite$Leaten + mite$Lmissing)
tot_larv # Always 7 larvae at start
# Check for response variable correlations
cor(mite[,5:11]) # One correlation >0.8 found between Rate of cannibalism and Larvae Eaten which
# makes sense given that Rate is a function of LarvaeEaten / Time
# Test if perfectly crossed
table(mite$Gender, mite$Block)
# Create contingency tables for Fisher's exact test of independence of gender/line to dispersal.
conting <- table(Gender, Dispersal)
conting
barplot(conting, beside=T, legend=T, xlab="Dispersal", ylab="Count")
# Load in the data, save as a variable and check it has been read in correctly. Check dimensions,
# summary and first few rows
mite <- as_tibble(read.csv("Project/cannibal_data.csv"))
setwd("C:\Users\Danny\Documents\Ecological Data Analysis")
setwd("\Users\Danny\Documents\Ecological Data Analysis")
setwd("/Users/Danny/Documents/Ecological Data Analysis")
# Load in the data, save as a variable and check it has been read in correctly. Check dimensions,
# summary and first few rows
mite <- as_tibble(read.csv("Project/cannibal_data.csv"))
View(mite)
setwd("/users/Danny/Documents/Experiment")
candida <- read_excel("Experiment/candida_data.xlsx")
library(tidyverse)
library(readxl)
library(ggpubr)
library(car)
library(emmeans)
setwd("/users/Danny/Documents/Experiment")
candida <- read_excel("Experiment/candida_data.xlsx")
candida <- read_excel("Experiment/candida_data.xlsx")
setwd("/users/Danny/Documents")
candida <- read_excel("Experiment/candida_data.xlsx")
candida$Heat <- as.factor(candida$Heat)
candida$Metal <- as.factor(candida$Metal)
mod1 <- aov(Expression~Treatment, data=subset(candida, Target=="Vit"))
summary(mod1)
outlierTest(mod1)
plot(mod1)
library(ggsci) # colour palette library
p <- ggboxplot(subset(candida, Target=="Vit"), x="Treatment", y="Expression",
add="jitter", fill="Treatment", palette="npg", bxp.errorbar=TRUE,
bxp.errorbar.width=0.2, show.legend=FALSE,
xlab="Treatment Group", ylab="Vg Expression Level")+
stat_compare_means(method="anova",
label.x = 3, label.y = 1.5)
stat_compare_means(aes(label=..p.signif..))
p
# Now perform post-hoc to determine which means have sig diff.
pairwise.t.test(subset(candida, Target=="Vit")$Expression, subset(candida, Target=="Vit")$Treatment,
p.adjust.method="bonf")
TukeyHSD(mod1) # No significant differences in the mean vitrellogenin expression
# A further way of doing this is with the emmeans package which gives useful summaries.
vit_means <- emmeans(mod1, spec="Treatment")
summary(vit_means)
# Can choose other adjustment methods
pairs(vit_means, adjust="bonferroni")
# Plot the means
plot(vit_means, comparisons=TRUE)
library(ggsci) # colour palette library
p <- ggboxplot(subset(candida, Target=="Vit"), x="Treatment", y="Expression",
add="jitter", fill="Treatment", palette="npg", bxp.errorbar=TRUE,
bxp.errorbar.width=0.2, show.legend=FALSE,
xlab="Treatment Group", ylab="Vg Expression Level")+
stat_compare_means(method="anova",
label.x = 3, label.y = 1.5)
install.packages("ggsci")
p <- ggboxplot(subset(candida, Target=="Vit"), x="Treatment", y="Expression",
add="jitter", fill="Treatment", palette="npg", bxp.errorbar=TRUE,
bxp.errorbar.width=0.2, show.legend=FALSE,
xlab="Treatment Group", ylab="Vg Expression Level")+
stat_compare_means(method="anova",
label.x = 3, label.y = 1.5)
library(ggpubr)
install.packages("ggpubr")
install.packages("ggpubr")
install.packages("emmeans")
install.packages("emmeans")
install.packages("emmeans")
install.packages("car")
library(tidyverse)
library(readxl)
library(ggpubr)
library(car)
library(emmeans)
library(ggsci) # colour palette library
p <- ggboxplot(subset(candida, Target=="Vit"), x="Treatment", y="Expression",
add="jitter", fill="Treatment", palette="npg", bxp.errorbar=TRUE,
bxp.errorbar.width=0.2, show.legend=FALSE,
xlab="Treatment Group", ylab="Vg Expression Level")+
stat_compare_means(method="anova",
label.x = 3, label.y = 1.5)
stat_compare_means(aes(label=..p.signif..))
p
?ggboxplot
rm=ls()
rm(ls=())
Sys.which('make')
install.packages('tabulizer')
ghit::install_github("ropensci/tabulizer")
git::install_github("ropensci/tabulizer")
devtools::install_github("ropensci/tabulizer")
remotes::install_github(c("ropensci/tabulizerjars"))
sessionInfo()
install.packages('tabulizerjars')
remotes::install_github(c("ropensci/tabulizerjars"))
install.packages('tabulizerjars')
remotes::install_github(c("ropensci/tabulizerjars"))
sessionInfo()
install.packages('rJava')
devtools::install_github(c("ropensci/tabulizer"))
remotes::install_github(c("ropensci/tabulizerjars"))
sessionInfo()
library(rJava)
sessionInfo()
remotes::install_github(c("ropensci/tabulizerjars"))
.libPaths()
Sys.getenv()
install.packages('backports')
install.packages('glue')
BiocManager::install("chopsticks")
install.packages('Matrix')
BiocManager::install("chopsticks")
library(chopsticks)
?chopsticks
remove.packages("chopsticks", lib="~/R/win-library/4.1")
BiocManager::install("chopsticks")
BiocManager::install("chopsticks",force=TRUE)
?chopsticks
help(chopsticks)
library(tabulizer)
library(pegas)
gc()
# Human Footprint Maps
raw_hf_path <- "c:/users/danny/documents/popgen/maps/human_footprint/raw"
raw_hf_files <- list.files(raw_hf_path, pattern='tif$', full.names=TRUE)
raw_hf_predictors <- stack(raw_hf_files)
# Copernicus Maps
raw_cop_path <- "c:/users/danny/documents/popgen/maps/copernicus/high_resolution"
raw_cop_files <- list.files(raw_cop_path, pattern='tif$', full.names=TRUE)
raw_cop_predictors <- stack(raw_cop_files)
bc_predictors
raw_cop_predictors
res(bc_predictors) / res(raw_hf_predictors)
res(bc_predictors) / res(raw_cop_predictors)
test_source <- raw_cop_predictors[[7]]
resolution <- res(bc_predictors)
fact <- resolution/res(test_source)
fact
agg_raster <- aggregate(test_source, fact)
library(pegas)
library(tabulizer)
library(dplyr)
library(plyr)
library(ade4)
library(raster)
library(stringr)
bc_path <- "c:/users/danny/documents/popgen/maps/bioclim"
bc_files <- list.files(bc_path, pattern='tif$', full.names=TRUE)
bc_predictors <- stack(bc_files)
# Human Footprint Maps
raw_hf_path <- "c:/users/danny/documents/popgen/maps/human_footprint/raw"
raw_hf_files <- list.files(raw_hf_path, pattern='tif$', full.names=TRUE)
raw_hf_predictors <- stack(raw_hf_files)
# Copernicus Maps
raw_cop_path <- "c:/users/danny/documents/popgen/maps/copernicus/high_resolution"
raw_cop_files <- list.files(raw_cop_path, pattern='tif$', full.names=TRUE)
raw_cop_predictors <- stack(raw_cop_files)
test_source <- raw_cop_predictors[[7]]
resolution <- res(bc_predictors)
fact <- resolution/res(test_source)
fact
agg_raster <- aggregate(test_source, fact)
library(pegas)
library(tabulizer)
library(dplyr)
library(plyr)
library(ade4)
library(raster)
library(stringr)
setwd("C:/Users/Danny/Documents/PopGen")
## Extracting locality and sample data from pdf files
# this function runs tabulizer on a given pdf file to extract tables between page numbers given as arguments.
# sometimes extra empty rows are given at the top of each table so there is an option to skip these.
extract_pdf_tables <- function(file, start_page, end_page, rows_to_skip) {
final_df = tab = ldply(extract_tables(file,pages=start_page,output="data.frame"),data.frame)[FALSE,]
for (page in start_page:end_page) {
tab = extract_tables(file, pages=page, output="data.frame")
df = ldply(tab,data.frame)
df = df[-1:-rows_to_skip,]
final_df <- rbind(final_df, df)
}
return(final_df)
}
### Environmental Spatial Data ###
# Bioclim Maps
bc_path <- "c:/users/danny/documents/popgen/maps/bioclim"
bc_files <- list.files(bc_path, pattern='tif$', full.names=TRUE)
bc_predictors <- stack(bc_files)
getwd()
setwd("C:/Users/Danny/Documents/projects/species-distribution-modelling")
# Bioclim Maps
bc_path <- "map_files/bioclim"
bc_files <- list.files(bc_path, pattern='tif$', full.names=TRUE)
bc_predictors <- stack(bc_files)
# read in vcf file and preprocess
bv_vcf <- read.vcf("data/bank_vole/SNP.vcf")
# read in vcf file and preprocess
bv_vcf <- read.vcf("SNP.vcf")
bv_vcf$id <- rownames(bv_vcf)
bv_final <- merge(bv_df, bv_vcf)
bv_loci <- within(bv_final, rm('long','lat','id'))
loci_df <- cbind(bv_loci$pop, bv_loci[,2:ncol(bv_loci)] %>%
mutate_all(funs(str_replace_all(.,"C","1"))) %>%
mutate_all(funs(str_replace_all(.,"G","2"))) %>%
mutate_all(funs(str_replace_all(.,"A","3"))) %>%
mutate_all(funs(str_replace_all(.,"T","4"))) %>%
mutate_all(funs(str_replace_all(.,"/",""))) %>%
mutate_all(function(x) as.numeric(as.character(x))))
bv_loci <- within(bv_final, rm('long','lat','id'))
bv_final <- merge(bv_df, bv_vcf)
# extract location data from pdf table
bv_extract <- extract_pdf_tables("supplementary_table.pdf",start_page=2,end_page=27,
rows_to_skip = 4)
bv_df <- bv_extract %>% dplyr::select(X, X.1, X.3, X.4)
bv_df$X <- paste('CG_', bv_df$X, sep='')
names(bv_df) <- c('id','pop','lat','long')
# read in vcf file and preprocess
bv_vcf <- read.vcf("SNP.vcf")
bv_vcf$id <- rownames(bv_vcf)
bv_final <- merge(bv_df, bv_vcf)
bv_loci <- within(bv_final, rm('long','lat','id'))
loci_df <- cbind(bv_loci$pop, bv_loci[,2:ncol(bv_loci)] %>%
mutate_all(funs(str_replace_all(.,"C","1"))) %>%
mutate_all(funs(str_replace_all(.,"G","2"))) %>%
mutate_all(funs(str_replace_all(.,"A","3"))) %>%
mutate_all(funs(str_replace_all(.,"T","4"))) %>%
mutate_all(funs(str_replace_all(.,"/",""))) %>%
mutate_all(function(x) as.numeric(as.character(x))))
# extract just coordinates
coords <- unique(bv_final[,c('pop','long','lat')])
coords <- coords[!(coords$pop=='Wicken' & coords$lat == 52.28),] # remove duplicate coordinate for Wicken pop
coords <- coords[order(coords$pop),]
coords <- coords %>%
mutate(pop = factor(pop)) %>%
mutate_all(function(x) as.numeric(x))
coords
## Calculate Genetic Distance ##
genet_dist <- genet.dist(loci_df,diploid=TRUE,method="Fst")
library(pegas)
library(tabulizer)
library(dplyr)
library(plyr)
library(ade4)
library(raster)
library(stringr)
## Calculate Genetic Distance ##
genet_dist <- genet.dist(loci_df,diploid=TRUE,method="Fst")
library(hierfstat)
library(vegan)
library(ecodist)
## Calculate Genetic Distance ##
genet_dist <- genet.dist(loci_df,diploid=TRUE,method="Fst")
genet_dist
## Calculate Geographic Distance ##
geog_dist <- as.dist(geod(coords))
geog_dist
## Calculate environmental distance ##
path <- "map_files/bioclim"
bioclim_files <- list.files(path, pattern='tif$',full.names=TRUE)
# create a rasterStack of predictor variables and crop to same extent as species occurences
predictors <-  stack(bioclim_files)
## Calculate environmental distance ##
path <- "map_files/bioclim"
bioclim_files <- list.files(path, pattern='tif$',full.names=TRUE)
# create a rasterStack of predictor variables and crop to same extent as species occurences
predictors <-  stack(bioclim_files)
# extract environmental values at coordinates
extraction <- extract(predictors, coords, 'bilinear')
coords
coords <- coords[,c('long','lat')]
# extract environmental values at coordinates
extraction <- extract(predictors, coords, 'bilinear')
# PCA for feature extraction to determine environmental distance
pca_mod <- rda(extraction, scale=TRUE)
summary(pca_mod)
biplot(pca_mod)
pca_scores <- scores(pca_mod,choices=c(1:4))$sites[,c(1:4)]
env_dist <- dist(pca_scores)
env_dist
length(env_dist)
## Calculate resistance distance ##
bvres <- read.table("circuitscape/circuitscape_resistances.out",
header=TRUE, row.names=1)
max(bvres)
bvres
res_dist <- as.dist(bvres)
length(res_dist)
res_dist
## Multiple Regresion on Distance Matrices
mrm <- MRM(genet_dist ~ geog_dist + env_dist + res_dist, nperm=999, mrank=TRUE)
mrm
plot(genet_dist, geog_dist)
plot(genet_dist, env_dist)
plot(genet_dist, res_dist)
mod <- lm(res_dist ~ genet_dist)
mod
abline(mod)
mrm
